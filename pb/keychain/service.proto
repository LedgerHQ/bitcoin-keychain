syntax = "proto3";

package pb.keychain;
option go_package = ".;keychain";
option java_package = "co.ledger.protobuf";

import "google/protobuf/empty.proto";

service KeychainService {
  // Create a new keychain by descriptor.
  rpc CreateKeychain(CreateKeychainRequest) returns (KeychainInfo) {}

  // Delete a keychain by descriptor.
  rpc DeleteKeychain(DeleteKeychainRequest) returns (google.protobuf.Empty) {}

  // Get keychain metadata.
  rpc GetKeychainInfo(GetKeychainInfoRequest) returns (KeychainInfo) {}

  // Mark a batch of addresses as used.
  rpc MarkAddressesAsUsed(MarkAddressesAsUsedRequest) returns (google.protobuf.Empty) {}

  // Get fresh addresses for a registered keychain and the provided Change.
  rpc GetFreshAddresses(GetFreshAddressesRequest) returns (GetFreshAddressesResponse) {}

  // Get a list of all address that can be observed by the keychain.
  rpc GetAllObservableAddresses(GetAllObservableAddressesRequest) returns (GetAllObservableAddressesResponse) {}
}

// BitcoinNetwork enumerates the list of all supported Bitcoin networks. It
// also indicates the coin for which the networks are defined, in this case,
// Bitcoin.
//
// This enum type may be used by gRPC clients to differentiate protocol
// behaviour, magic numbers, addresses, keys, etc., for one network from those
// intended for use on another network.
enum BitcoinNetwork {
  BITCOIN_NETWORK_UNSPECIFIED = 0;  // Fallback value if unrecognized / unspecified
  BITCOIN_NETWORK_MAINNET     = 1;  // Main network
  BITCOIN_NETWORK_TESTNET3    = 2;  // Current test network (since Bitcoin Core v0.7)
  BITCOIN_NETWORK_REGTEST     = 3;  // Regression test network
}

// Change is an enum type to indicate whether an address belongs to the
// external chain (receive) or the internal chain (change).
enum Change {
  CHANGE_UNSPECIFIED = 0;  // fallback value if unrecognized / unspecified
  CHANGE_EXTERNAL    = 1;  // external chain
  CHANGE_INTERNAL    = 2;  // internal chain
}

message CreateKeychainRequest {
  string account_descriptor = 1;
  uint32 lookahead_size = 2;
  BitcoinNetwork network = 3;
}

message DeleteKeychainRequest {
  string account_descriptor = 1;
}

message GetKeychainInfoRequest {
  string account_descriptor = 1;
}

message KeychainInfo {
  // Account descriptor of the keychain, at HD depth 3. MUST include the key
  // origin information.
  // Ref: https://github.com/bitcoin/bitcoin/blob/master/doc/descriptors.md
  string account_descriptor = 1;

  // Extended public key serialized with standard HD version bytes.
  string xpub = 2;

  // Extended public key serialized with SLIP-0132 HD version bytes.
  // Ref: https://github.com/satoshilabs/slips/blob/master/slip-0132.md
  string slip32_extended_public_key = 3;

  // Numerical size of the lookahead zone.
  uint32 lookahead_size = 4;

  // Scheme defines the scheme on which a keychain entry is based.
  enum Scheme {
    SCHEME_UNSPECIFIED = 0;  // fallback value if unrecognized / unspecified
    SCHEME_BIP44       = 1;  // indicates that the keychain scheme is legacy.
    SCHEME_BIP49       = 2;  // indicates that the keychain scheme is segwit.
    SCHEME_BIP84       = 3;  // indicates that the keychain scheme is native segwit.
  }
  Scheme scheme = 5;

  // Network for which the keychain is defined.
  //
  // Although the network information can be inferred from the account
  // descriptor, it is often not enough to differentiate between Testnet3
  // and Regtest networks, typically the case with the BIP84 scheme.
  //
  // This field is mostly useful for encoding addresses for a specific
  // network.
  BitcoinNetwork network = 6;
}

message MarkPathAsUsedRequest {
  // Account descriptor of the keychain
  string account_descriptor = 1;

  // Derivation path relative to BIP-32 account path-level.
  //
  // The derivation path is represented by an array of child indexes. Each
  // child index in the path must be between 0 and 2^31-1, i.e., they should
  // not be hardened.
  repeated uint32 derivation = 2;
}

message GetFreshAddressesRequest {
  // Account descriptor of the keychain
  string account_descriptor = 1;

  // The chain on which the fresh addresses must be issued on.
  Change change = 2;

  // The number of fresh addresses to derive.
  uint32 batch_size = 3;
}

message GetFreshAddressesResponse {
  repeated string addresses = 1;
}

message MarkAddressesAsUsedRequest {
  // Account descriptor of the keychain
  string account_descriptor = 1;

  // Addresses to be marked as used
  repeated string addresses = 2;
}

message GetAllObservableAddressesRequest {
  // Account descriptor of the keychain
  string account_descriptor = 1;

  // The chain on which the observable addresses must be returned
  Change change = 2;

  // Start address index
  uint32 from_index = 3;

  // End address index
  uint32 to_index = 4;
}

message GetAllObservableAddressesResponse {
  repeated string addresses = 1;
}